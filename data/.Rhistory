# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
plot(spldf.dir0.lst.path[[1]])
plot(spldf.dir0.lst.path[[2]])
plot(spldf.dir0.lst.path[[3]])
plot(spldf.dir0.lst.path[[4]])
plot(spldf.dir0.lst.path[[5]])
spldf.dir0.paths <- do.call(bind, spldf.dir0.lst.path)
plot(spldf.dir0.lst.path)
spldf.dir0.paths
pwd()
dir
dir()
writeOGR(spldf.dir0.paths,".","dir0.paths",driver="ESRI Shapefile")
spldf.dir0.paths
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Stops$Lon, x$Direction0$Stops$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(
list(line.busLine),
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
)
# with busLine create a dataframe
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
warnings()
?Lines()
?SpatialLines
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
dir0.lst.path <- lst.wmata.path[!sapply(
seq_along(lst.wmata.path),
function(i) {
# an if else statement to return index of items in for those routes with stop geometry objects that aren't null
if(is.null(lst.wmata.path[[i]]$Direction0$Stops)){} else {
if(length(lst.wmata.path[[i]]$Direction0$Stops)>1) {i}
}
}
) %in% "NULL"]
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Stops$Lon, x$Direction0$Stops$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
# with busLine create a dataframe
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
warnings()
spldf.dir0.paths <- do.call(bind, spldf.dir0.lst.path)
plot(spldf.dir0.paths)
writeOGR(spldf.dir0.paths,".","dir0.paths",driver="ESRI Shapefile",overwrite_layer = TRUE)
lst.wmata.path[[1]]$Direction0$Shape
lst.wmata.path[[2]]$Direction0$Shape
lst.wmata.path[[3]]$Direction0$Shape
lst.wmata.path[[4]]$Direction0$Shape
lst.wmata.path[[5]]$Direction0$Shape
lst.wmata.path[[6]]$Direction0$Shape
lst.wmata.path[[7]]$Direction0$Shape
lst.wmata.path[[7]]$Direction0$Shape
lst.wmata.path[[2]]$Direction0$Shape
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Shape$Lon, x$Direction0$Shape$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(line.busLine), function(i) line.busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
dir0.lst.path <- lst.wmata.path[!sapply(
seq_along(lst.wmata.path),
function(i) {
# an if else statement to return index of items in for those routes with stop geometry objects that aren't null
if(is.null(lst.wmata.path[[i]]$Direction0$Shape)){} else {
if(length(lst.wmata.path[[i]]$Direction0$Shape)>1) {i}
}
}
) %in% "NULL"]
seq_along(lst.wmata.path),
function(i) {
# an if else statement to return index of items in for those routes with stop geometry objects that aren't null
if(is.null(lst.wmata.path[[i]]$Direction0$Shape)){} else {
if(length(lst.wmata.path[[i]]$Direction0$Shape)>1) {i}
}
}
dir0.lst.path <- lst.wmata.path[!sapply(
seq_along(lst.wmata.path),
function(i) {
# an if else statement to return index of items in for those routes with stop geometry objects that aren't null
if(is.null(lst.wmata.path[[i]]$Direction0$Shape)){} else {
if(length(lst.wmata.path[[i]]$Direction0$Shape)>1) {i}
}
}
) %in% "NULL"]
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Shape$Lon, x$Direction0$Shape$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(line.busLine), function(i) line.busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
spldf.dir0.lst.path
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Shape$Lon, x$Direction0$Shape$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
busLine@lines
busLine@lines[[1]]@ID
spldf.dir0.lst.path[[1]]@data
spldf.dir0.paths <- do.call(bind, spldf.dir0.lst.path)
spldf.dir0.paths@data
?do.call
?bind
spldf.dir0.lst.path[[1]]@data$len
spldf.dir0.lst.path[[1]]@data
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Shape$Lon, x$Direction0$Shape$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe, keeping both length of route and the name of the route
df.busLine <- data.frame(length = len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])),
route = sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID))
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Shape$Lon, x$Direction0$Shape$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe, keeping both length of route and the name of the route
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])),
sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID))
# give columns names
names(df.busLine) <- c("length","route")
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Shape$Lon, x$Direction0$Shape$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe, keeping both length of route and the name of the route
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])),
route = sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
spldf.dir0.paths <- do.call(bind, spldf.dir0.lst.path)
spldf.dir0.paths@data
rgdal
writeOGR(spldf.dir0.paths,".",dir0.paths,driver="ESRI Shapefile",overwrite_layer = TRUE)
writeOGR(spldf.dir0.paths,".",'dir0.paths',driver="ESRI Shapefile",overwrite_layer = TRUE)
dir0.lst.path <- lst.wmata.path[!sapply(
seq_along(lst.wmata.path),
function(i) {
# an if else statement to return index of items in for those routes with stop geometry objects that aren't null
if(is.null(lst.wmata.path[[i]]$Direction0$Stops)){} else {
if(length(lst.wmata.path[[i]]$Direction0$Stops)>1) {i}
}
}
) %in% "NULL"]
spldf.dir0.lst.path <- sapply(
dir0.lst.path,
function(x)
{
# credit StackExchange user fdetsch at tinyurl.com/zdqyewj for how this was figured out. Thanks dude.
# get matxix of latlon from JSON in lst.wmata.path
latlog.busLine <- cbind(x$Direction0$Stops$Lon, x$Direction0$Stops$Lat)
# pass latlon.busLine through Line() to make it a line
line.busLine <- Line(latlog.busLine)
# pass line.busLine through Lines() as a list, giving an ID to it, here the route and direction
line.busLine <- Lines(list(line.busLine), ID=paste(x$RouteID,x$Direction0$DirectionText,sep="."))
# pass line.busLine through SpatialLines as a list again, set its CRS. here wgs84 is best tinyurl.com/jamjxxl so proj lata
busLine <- SpatialLines(list(line.busLine),CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# with busLine create a dataframe, keeping both length of route and the name of the route
df.busLine <- data.frame(len = sapply(1:length(busLine), function(i) gLength(busLine[i, ])),
route = sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID))
# apply ID set when creating line.busLine (on line 67) to give name to df.busLine rows
rownames(df.busLine) <- sapply(1:length(busLine), function(i) busLine@lines[[i]]@ID)
# make SpatialLinesDataFrame from x that will be returned at x's index in dir0.lst.wmata.path
SpatialLinesDataFrame(busLine,df.busLine)
})
spldf.dir0.paths <- do.call(bind, spldf.dir0.lst.path)
writeOGR(spldf.dir0.paths,".",'dir0.paths',driver="ESRI Shapefile",overwrite_layer = TRUE)
wmata.routes
wmata.routes$Routes
install.packages( packages.index )
packages <- c( "jsonlite", "rgdal", "rgeos", "raster" )
packages.installed <- as.data.frame( installed.packages()[,c(1,3:4)] )
rownames( packages.installed ) <- NULL
packages.installed <- packages.installed[is.na(
packages.installed$Priority),
1:2,drop=FALSE]
packages.index <- packages[!packages %in% as.character(packages.installed$Package)]
install.packages( packages.index )
for( package in packages.index ) {
library( package, character.only = TRUE )
}
packages.index
for( package in packages ) {
library( package, character.only = TRUE )
}
key<-readline( prompt = "Provide API Key: ")
wmata.routes <- fromJSON( txt = system( paste(
'curl -v -X GET "https://api.wmata.com/Bus.svc/json/jRoutes" -H "api_key: ',
key,' "', sep = "" ) , intern=TRUE ))
wmata.stops <- fromJSON( txt = system( paste(
'curl -v -X GET "https://api.wmata.com/Bus.svc/json/jStops" -H "api_key: ',
key,' "', sep = "" ) , intern=TRUE ))
wmata.stops$Stops$StopID
wmata.stops$Stops$Lon
wmata.stops$Stops$Routes
wmata.routes$Routes$Name
wmata.routes$Routes$RouteID
wmata.routes <- fromJSON( txt = system( paste(
'curl -v -X GET "https://api.wmata.com/Bus.svc/json/jRoutes" -H "api_key: ',
key,' "', sep = "" ) , intern=TRUE ))$RouteID
wmata.routes
wmata.routes <- fromJSON( txt = system( paste(
'curl -v -X GET "https://api.wmata.com/Bus.svc/json/jRoutes" -H "api_key: ',
key,' "', sep = "" ) , intern=TRUE ))
wmata.routes
is.data.frame(wmata.routes)
is.matrix(wmata.routes)
wmata.routes$Routes$RouteID
wmata.stops$Stops$Routes
wmata.stops$Stops$Routes[wmata.stops$Stops$Routes %in% "c21"]
wmata.stops$Stops$Routes[wmata.stops$Stops$Routes %in% "C21"]
wmata.stops$Stops$Routes[wmata.stops$Stops$Routes %in% "C21"]
wmata.stops$Stops$Routes
any(sapply(wmata.stops$Stops$Routes,function(x) x[x %in% "C21"]))
any(sapply(wmata.stops$Stops$Routes,function(x) x %in% "C21"))
any(sapply(as.character(wmata.stops$Stops$Routes),function(x) x %in% "C21"))
wmata.stops$Stops$Routes[sapply(as.character(wmata.stops$Stops$Routes),function(x) x %in% "C21"))]
wmata.stops$Stops$Routes[sapply(as.character(wmata.stops$Stops$Routes),function(x) x %in% "C21")]
wmata.stops$Stops$Routes[sapply(as.character(wmata.stops$Stops$Routes),function(x) "C21" %in% x)]
wmata.stops$Stops[sapply(as.character(wmata.stops$Stops$Routes),function(x) "C21" %in% x)]
wmata.stops$Stops$Routes
grep("C21",wmata.routes$Routes$RouteID)
wmata.stops
wmata.stops$Stops$Routes
grep("C21",wmata.stops$Stops$Routes)
wmata.stops$Stops$Routes[[485]]
wmata.stops$Stops$Routes[[485]]
wmata.stops$Stops$Routes[[774]]
wmata.stops$Stops$Routes[[775]]
grep("C21v1",wmata.stops$Stops$Routes)
lenght(wmata.stops$Stops)
lenght(wmata.stops$Stops$StopID)
length(wmata.stops$Stops$StopID)
length(wmata.stops$Stops)
length(wmata.stops$Stops$Name)
wmata.stops$Stops[grep("C21v1",wmata.stops$Stops$Routes)]
wmata.stops$Stops[grep("C21v1",wmata.stops$Stops$Routes),]
wmata.stops$Stops[!grep("C21v1",wmata.stops$Stops$Routes),]
wmata.stops$Stops[grep("C21v1",wmata.stops$Stops$Routes)]
wmata.stops$Stops[grep("C21v1",wmata.stops$Stops$Routes),]
wmata.stops$Stops
wmata.stops$Stops$StopID
wmata.stops$Stops$Name
wmata.stops$Stops$Routes
length(wmata.stops$Stops$Routes)
length(wmata.stops$Stops$StopID)
length(wmata.stops$Stops$StopID[grep("C21v1",wmata.stops$Stops$Routes)])
wmata.stops$Stops$StopID[grep("C21v1",wmata.stops$Stops$Routes)]
wmata.stops$Stops$StopID[grep("C21",wmata.stops$Stops$Routes)]
wmata.routes$Routes$RouteID
wmata.routes$Routes$RouteID[[1]]
grep("wmata.routes$Routes$RouteID[[1]]",wmata.stops$Stops$Routes)
grep("wmata.routes$Routes$RouteID[[2]]",wmata.stops$Stops$Routes)
grep(wmata.routes$Routes$RouteID[[2]],wmata.stops$Stops$Routes)
grep(wmata.routes$Routes$RouteID[[1]],wmata.stops$Stops$Routes)
grep(wmata.routes$Routes$RouteID[[3]],wmata.stops$Stops$Routes)
wmata_routes <- wmata.routes
wmata_stops <- wmata.stops
wmata_stops$Stops$Name
librarh(maptools)
library(maptools)
install.packages("maptools")
library(maptools)
install.packages("devtools")
library(devtools)
setwd("/Users/giscomputerextra2/Desktop/max/github/maxgrossman/dclatebus")
library("/packages/points_to_lines",character.only = TRUE)
library("/packages/points_to_lines.R",character.only = TRUE)
install("/packages/points_to_lines")
install("/packages/points_to_lines.R")
install("packages/points_to_lines.R")
install("packages/")
install("packages/points_to_lines")
routes_index <- grep( wmata_routes$Routes$RouteID , wmata_stops$Stops$Routes )
routes_index <- grep( wmata_routes$Routes$RouteID[[1]] , wmata_stops$Stops$Routes )
routes_index
stops_nam <- wmata_stops$Stops$StopID[ routes_index ]
stops_nam
stops_nam <- wmata_stops$Stops$Name[ routes_index ]
stops_nam
stops_loc <- SpatialPoints( cbind( wmata_stops$Stops$Lon[ routes_index],
wmata_stops$Stops$Lat[ routes_index] ),
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
)
stops_loc
stops_df <- data.frame( nam = stops_name )
stops_df <- data.frame( nam = stops_nam )
stops_df
route_spdf <- SpatialPointsDataFrame( stops_loc, data = stops_df )
plot( route_spdf )
routes_spdf
route_spdf@coords
route_line <- SpatialLines(list(Lines(list(Line(route_spdf@coords)), "id")))
plot(route_line)
library(points_to_lintes)
library(points_to_lines)
library('/packages/points_to_lines/R')
points_to_line <- function(data, long, lat, id_field = NULL, sort_field = NULL) {
# Convert to SpatialPointsDataFrame
coordinates(data) <- c(long, lat)
# If there is a sort field...
if (!is.null(sort_field)) {
if (!is.null(id_field)) {
data <- data[order(data[[id_field]], data[[sort_field]]), ]
} else {
data <- data[order(data[[sort_field]]), ]
}
}
# If there is only one path...
if (is.null(id_field)) {
lines <- SpatialLines(list(Lines(list(Line(data)), "id")))
return(lines)
# Now, if we have multiple lines...
} else if (!is.null(id_field)) {
# Split into a list by ID field
paths <- sp::split(data, data[[id_field]])
sp_lines <- SpatialLines(list(Lines(list(Line(paths[[1]])), "line1")))
# I like for loops, what can I say...
for (p in 2:length(paths)) {
id <- paste0("line", as.character(p))
l <- SpatialLines(list(Lines(list(Line(paths[[p]])), id)))
sp_lines <- spRbind(sp_lines, l)
}
return(sp_lines)
}
}
stops_spdf <- SpatialPointsDataFrame( stops_loc, data = stops_df )
for( route_id in wmata_routes$Routes$RouteID ) {
# index the wmata_stops to get only those route_id passes through
routes_index <- grep( route_id , wmata_stops$Stops$Routes )
# grab stop names from wmata_stops wit the routes_index
stops_nam <- wmata_stops$Stops$Name[ routes_index ]
# make stops_loc, a SpatialPoints using lat,lon of indexed wmata_stops
stops_loc <- SpatialPoints( cbind( wmata_stops$Stops$Lon[ routes_index],
wmata_stops$Stops$Lat[ routes_index] ),
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
)
# create stops_df with the name of the stops, used next making routes_spdf
stops_df <- data.frame( nam = stops_nam )
# make the routes spdf
stops_spdf <- SpatialPointsDataFrame( stops_loc, data = stops_df )
# write these out to shapefiles
writeOGR( obj = stops_spdf,
dsn = "/data",
layer = paste( route_id, "stops", sep = "_" ),
driver = "ESRI Shapefile"
)
}
o
for( route_id in wmata_routes$Routes$RouteID ) {
# index the wmata_stops to get only those route_id passes through
routes_index <- grep( route_id , wmata_stops$Stops$Routes )
# grab stop names from wmata_stops wit the routes_index
stops_nam <- wmata_stops$Stops$Name[ routes_index ]
# make stops_loc, a SpatialPoints using lat,lon of indexed wmata_stops
stops_loc <- SpatialPoints( cbind( wmata_stops$Stops$Lon[ routes_index],
wmata_stops$Stops$Lat[ routes_index] ),
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
)
# create stops_df with the name of the stops, used next making routes_spdf
stops_df <- data.frame( nam = stops_nam )
# make the routes spdf
stops_spdf <- SpatialPointsDataFrame( stops_loc, data = stops_df )
# write these out to shapefiles
writeOGR( obj = stops_spdf,
dsn = "/data",
layer = paste( route_id, "stops", sep = "_" ),
driver = "ESRI Shapefile"
)
}
setwd("/Users/giscomputerextra2/Desktop/max/github/maxgrossman/dclatebus/data")
for( route_id in wmata_routes$Routes$RouteID ) {
# index the wmata_stops to get only those route_id passes through
routes_index <- grep( route_id , wmata_stops$Stops$Routes )
# grab stop names from wmata_stops wit the routes_index
stops_nam <- wmata_stops$Stops$Name[ routes_index ]
# make stops_loc, a SpatialPoints using lat,lon of indexed wmata_stops
stops_loc <- SpatialPoints( cbind( wmata_stops$Stops$Lon[ routes_index],
wmata_stops$Stops$Lat[ routes_index] ),
CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
)
# create stops_df with the name of the stops, used next making routes_spdf
stops_df <- data.frame( nam = stops_nam )
# make the routes spdf
stops_spdf <- SpatialPointsDataFrame( stops_loc, data = stops_df )
# write these out to shapefiles
writeOGR( obj = stops_spdf,
dsn = ".",
layer = paste( route_id, "stops", sep = "_" ),
driver = "ESRI Shapefile"
)
}
?spLines
stops_spdf
plot(stops_spdf)
spLines(stops_spdf)
plot(spLines(stops_spdf)
)
?spLines
